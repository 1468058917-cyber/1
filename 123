//C++����ʹ��
//#include  <stdint.h>//C++����ʹ��


#include  "Extended_kalman.h"
#include "arm_math.h"
#include  "stdio.h"

#ifndef PI
#define PI               3.14159265358979f
#endif
//#define sensors  1  //C++����ʹ��
/*==================================== Start ekf algorithm ========================================*/
const static char sensors = 1;//C++����ʹ��
/*==========================?��???��2?��y3?��??��===============================*/
static float  P_mag_ekf_temp[sensors][16],P_EKF[sensors][16], Q_GYR[sensors][16], Racc_static[sensors][9], Racc_use[sensors][9], Rmag_static[sensors][9], Rmag_use[sensors][9];
static float k_first[sensors] = { 0 };

static int InitNumber[sensors] = { 1 }; //��ʼ��֡����
static float MeanACC[sensors][3] = { 0 }; //��ʼ��֡ACC��ֵ
static float MeanMAG[sensors][3] = { 0 }; //��ʼ��֡MAG��ֵ
static float MAG_InitialModule[sensors] = { 0 }; //��ʵ�ų�MAGģֵ����Ҫ�ο�ֵ
static float MAG_InitialModule_m[sensors] = { 0 }; //�ٱ������µ�MAGģֵ����Ҫ�ο�ֵ, ���ö�̬ƽ����ģʽ��MAG_InitialModule_m = MAG_InitialModule_m * 0.99 + mag_ss * 0.01
static float MAG_Z0[sensors]; //��ʵ�ų���Z����ֵ��ֻҪ��̬��roll��pitch���������쳣����ô��ֵ�������жϴų��仯״̬��˫�ر��գ�
static float MAG_Zm[sensors]; //�ٱ������µ�Z����ֵ��ֻҪ��̬��roll��pitch���������쳣����ô��ֵ�������жϴų��仯״̬��˫�ر��գ�, ���ö�̬ƽ����ģʽ
static float MAG_Fa0[sensors][3]; //��ʵ�ų��ķ�����
static float MAG_Fam[sensors][3]; //�ٱ������µķ�����
static float MAG_MO0[sensors][3]; //��ʵ�ų��Ĵų���ֵ�۲�����
static float MAG_MOm[sensors][3]; //�ٱ������µĴų���ֵ�۲�����
static float MAG_OMOm[sensors][3]; //��ʵ�ų��Ĵų���ֵ�۲�����(������)
static float MAG_OFam[sensors][3]; //�ٱ������µĴų���ֵ�۲���������������
static char MAG_LastTrue[sensors]; //��һ֡�汱���λ
static char MAG_Change[sensors]; //��һ֡�汱���λ

//ACC EKF
static float X_ACC_EKF[sensors][3];
static float P_ACC_EKF[sensors][9];
static float Q_ACC_EKF[sensors][9];
static float R_ACC_EKF[sensors][9];
static float ERR_ACC_EKF[sensors];
//MAG EKF
static float X_MAG_EKF[sensors][6];
static float P_MAG_EKF[sensors][36];
static float Q_MAG_EKF[sensors][36];
static float R_MAG_EKF[sensors][9];
static float A_MAG_EKF[sensors][36];
static float H_MAG_EKF[sensors][18];

// ��̬���(�ֶ������)
static int gyrStatic[sensors];
static int accStatic[sensors];
static float accLast[sensors][3];
// �����˶����
//static float FastMovementTime[sensors];
static float QuitReturnCtrlNumber[sensors];
static int QuickRecover[sensors];//���ٻع�
// ��λ����
static float eye3[9], eye4[16], eye6[36];
static float jiaomThresold[sensors];
static float jiaommagThresold[sensors];
/*******************************************************************
��ʼ��
********************************************************************/
void mHand_EKF_Init(void)
{
	for (char i = 0; i < sensors; i++) {
		k_first[i] = 0;
		InitNumber[i] = 1;
		MAG_Fa0[i][0] = 0;
		MAG_Fa0[i][1] = 0;
		MAG_Fa0[i][2] = 0;
		MeanACC[i][0] = 0; //��ʼ��֡ACC��ֵ
		MeanACC[i][1] = 0;
		MeanACC[i][2] = 0;
		MeanMAG[i][0] = 0; //��ʼ��֡��ʼ��֡MAG��ֵ��ֵ
		MeanMAG[i][1] = 0;
		MeanMAG[i][2] = 0;
		MAG_InitialModule[i] = 0;
	}
}
/*******************************************************************
* @brief  ???����a??
* @param
* @param
*
* @retval
********************************************************************/
static void matrix_trans(float* mata, char r, char c, float* matb)
{
	char i, j;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			matb[j * r + i] = mata[i * c + j];
		}
	}
}
/*******************************************************************
* @brief  ???��?��?��
* @param
* @param
*
* @retval
********************************************************************/
static void matrix_add(float* mata, float* matb, char r, char c, float* matc)
{
	char i, j;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			matc[i * c + j] = mata[i * c + j] + matb[i * c + j];
		}
	}
}
/*******************************************************************
* @brief  ???��?��??
* @param
* @retval
********************************************************************/
static void matrix_sub(float* mata, float* matb, char r, char c, float* matc)
{
	char i, j;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			matc[i * c + j] = mata[i * c + j] - matb[i * c + j];
		}
	}
}
/*******************************************************************
* @brief  ???��?��3? mat1 * mat2
* @param  mat1 ��'???��DD??D��
* @param  columns1 ???��mat1��?��D��y
* @param  mat2 ��'???��DD??D��
* @param  mat  ��'???��DD??D��
*
* @retval
********************************************************************/
static void matrix_mul(float* mat1, char row1, char columns1, float* mat2, char columns2, float* mat)
{
	char i, j, k;
	for (i = 0; i < row1; i++)
	{
		for (j = 0; j < columns2; j++)
		{
			mat[i * columns2 + j] = 0.0;
			for (k = 0; k < columns1; k++)
			{
				mat[i * columns2 + j] += mat1[i * columns1 + k] * mat2[k * columns2 + j];
			}
		}
	}
}
/*******************************************************************
* @brief  4*4?��???��?��3? mat1 * mat2
* @param  mat1 ��'???��DD??D��
* @param  mat2 ��'???��DD??D��
* @param  mat  ��'???��DD??D��
*
* @retval
********************************************************************/
static void matrix_4_mul(float* mat1, float* mat2, float* mat)
{
	char i, j, k;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			mat[i * 4 + j] = 0.0;
			for (k = 0; k < 4; k++)
			{
				mat[i * 4 + j] += mat1[i * 4 + k] * mat2[k * 4 + j];
			}
		}
	}
}
/*******************************************************************
* @brief  3*3?��???��?��??
* @param
* @param
*
* @retval
********************************************************************/
static void matrix_3_inv(float* mata, float* mata_inv)
{
	float mata_det;
	mata_det = mata[0] * mata[4] * mata[8] + mata[1] * mata[5] * mata[6] + mata[2] * mata[3] * mata[7]
		- mata[2] * mata[4] * mata[6] - mata[5] * mata[7] * mata[0] - mata[8] * mata[1] * mata[3];
	mata_inv[0] = (mata[4] * mata[8] - mata[5] * mata[7]) / mata_det;
	mata_inv[1] = (mata[2] * mata[7] - mata[1] * mata[8]) / mata_det;
	mata_inv[2] = (mata[1] * mata[5] - mata[2] * mata[4]) / mata_det;
	mata_inv[3] = (mata[5] * mata[6] - mata[3] * mata[8]) / mata_det;
	mata_inv[4] = (mata[0] * mata[8] - mata[2] * mata[6]) / mata_det;
	mata_inv[5] = (mata[2] * mata[3] - mata[0] * mata[5]) / mata_det;
	mata_inv[6] = (mata[3] * mata[7] - mata[4] * mata[6]) / mata_det;
	mata_inv[7] = (mata[1] * mata[6] - mata[0] * mata[7]) / mata_det;
	mata_inv[8] = (mata[0] * mata[4] - mata[1] * mata[3]) / mata_det;
}

/*******************************************************************
* @brief  quat -> matic Axis b to n
* @param
* @param
* @retval null
***************************************0*****************************/
static void matrix_Cbn(float* quat, float* Cbn)
{
	Cbn[0] = quat[0] * quat[0] + quat[1] * quat[1] - quat[2] * quat[2] - quat[3] * quat[3];
	Cbn[1] = 2 * (quat[1] * quat[2] - quat[0] * quat[3]);
	Cbn[2] = 2 * (quat[1] * quat[3] + quat[0] * quat[2]);
	Cbn[3] = 2 * (quat[1] * quat[2] + quat[0] * quat[3]);
	Cbn[4] = quat[0] * quat[0] - quat[1] * quat[1] + quat[2] * quat[2] - quat[3] * quat[3];
	Cbn[5] = 2 * (quat[2] * quat[3] - quat[0] * quat[1]);
	Cbn[6] = 2 * (quat[1] * quat[3] - quat[0] * quat[2]);
	Cbn[7] = 2 * (quat[2] * quat[3] + quat[0] * quat[1]);
	Cbn[8] = quat[0] * quat[0] - quat[1] * quat[1] - quat[2] * quat[2] + quat[3] * quat[3];
}
/*******************************************************************
ƽ����
********************************************************************/
static float SquaresSum(float* vec, unsigned int len) {
	float q_len = 0;
	for (int i = 0; i < len; i++) {
		q_len += vec[i] * vec[i];
	}
	return q_len;
}
/*******************************************************************
ģֵ
********************************************************************/
static float Module(float* vec, unsigned int len)
{
	return sqrtf(SquaresSum(vec, len));
}
/*******************************************************************
��һ��
********************************************************************/
static char Norm(float* vec, unsigned int len)
{
	float q_len = Module(vec, len);
	if (q_len == 0) { return 0; }
	for (int i = 0; i < len; i++) {
		vec[i] /= q_len;
	}
	return 1;
}
/*******************************************************************
ACos
********************************************************************/
static float ACos(float value)
{
	if (value >= 1)return 0;
	else if (value <= -1)return PI;
	else {
		return acosf(value);
	}
}
/*******************************************************************
����
********************************************************************/
static char Copy(float* out, float* in, unsigned int len)
{
	for (int i = 0; i < len; i++) {
		out[i] = in[i];
	}
	return 1;
}
/*******************************************************************
* @brief
* @retval
***************************************0*****************************/
static void ACCEKF_init(char sensor) {

	for (int i = 0; i < 9; i++)
	{
		P_ACC_EKF[sensor][i] = 0;
		Q_ACC_EKF[sensor][i] = 0;
		R_ACC_EKF[sensor][i] = 0;
	}
	ERR_ACC_EKF[sensor] = 0;
	P_ACC_EKF[sensor][0] = 1e-3f; P_ACC_EKF[sensor][4] = 1e-3f; P_ACC_EKF[sensor][8] = 1e-3f;
	Q_ACC_EKF[sensor][0] = 3e-1f; Q_ACC_EKF[sensor][4] = 3e-1f; Q_ACC_EKF[sensor][8] = 3e-1f;
	R_ACC_EKF[sensor][0] = 1e+3f; R_ACC_EKF[sensor][4] = 1e+3f; R_ACC_EKF[sensor][8] = 1e+3f;
}
static void MAGEKF_init(char sensor) {

	for (int i = 0; i < 36; i++)
	{
		A_MAG_EKF[sensor][i] = 0;
		P_MAG_EKF[sensor][i] = 0;
		Q_MAG_EKF[sensor][i] = 0;
		if (i < 9)
		{
			R_MAG_EKF[sensor][i] = 0;
		}
		if (i < 18) {
			H_MAG_EKF[sensor][i] = 0;
		}
	}
	A_MAG_EKF[sensor][0] = 1; A_MAG_EKF[sensor][7] = 1; A_MAG_EKF[sensor][14] = 1;
	A_MAG_EKF[sensor][21] = 1; A_MAG_EKF[sensor][28] = 1; A_MAG_EKF[sensor][35] = 1;
	P_MAG_EKF[sensor][0] = 1e-3f; P_MAG_EKF[sensor][7] = 1e-3f; P_MAG_EKF[sensor][14] = 1e-3f;
	P_MAG_EKF[sensor][21] = 1e-3f; P_MAG_EKF[sensor][28] = 1e-3f; P_MAG_EKF[sensor][35] = 1e-3f;
	Q_MAG_EKF[sensor][0] = 1e-2f; Q_MAG_EKF[sensor][7] = 1e-2f; Q_MAG_EKF[sensor][14] = 1e-2f;
	Q_MAG_EKF[sensor][21] = 1e-2f; Q_MAG_EKF[sensor][28] = 1e-2f; Q_MAG_EKF[sensor][35] = 1e-2f;
	R_MAG_EKF[sensor][0] = 1e+2f; R_MAG_EKF[sensor][4] = 1e+2f; R_MAG_EKF[sensor][8] = 1e+2f;
	H_MAG_EKF[sensor][0] = 1; H_MAG_EKF[sensor][4] = 1; H_MAG_EKF[sensor][8] = 1;
	H_MAG_EKF[sensor][9] = 1; H_MAG_EKF[sensor][13] = 1; H_MAG_EKF[sensor][17] = 1;

}
static void EYE_init(){
	for (int i = 0; i < 36; i++)
	{
		eye6[i] = 0;
		if (i < 9)
		{
			eye3[i] = 0;
		}
		if (i < 16) {
			eye4[i] = 0;
		}
	}
	eye3[0] = 1; eye3[4] = 1; eye3[8] = 1;
	eye4[0] = 1; eye4[5] = 1; eye4[10] = 1; eye4[15] = 1;
	eye6[0] = 1; eye6[7] = 1; eye6[14] = 1;
	eye6[21] = 1; eye6[28] = 1; eye6[35] = 1;
}
static void ekf_init(char sensor)
{
	for (int i = 0; i < 16; i++)
	{
		P_EKF[sensor][i] = 0;
		Q_GYR[sensor][i] = 0;
		if (i < 9)
		{
			Racc_static[sensor][i] = 0;
			Racc_use[sensor][i] = 0;
			Rmag_static[sensor][i] = 0;
			Rmag_use[sensor][i] = 0;
		}
	}
	P_EKF[sensor][0] = 1e-1f; P_EKF[sensor][5] = 1e-1f; P_EKF[sensor][10] = 1e-1f; P_EKF[sensor][15] = 1e-1f;
	Q_GYR[sensor][0] = 1e-2f; Q_GYR[sensor][5] = 1e-2f; Q_GYR[sensor][10] = 1e-2f; Q_GYR[sensor][15] = 1e-2f;
	Racc_static[sensor][0] = 1e+2f; Racc_static[sensor][4] = 1e+2f; Racc_static[sensor][8] = 1e+2f;
	Rmag_static[sensor][0] = 8e+2f; Rmag_static[sensor][4] = 8e+2f; Rmag_static[sensor][8] = 8e+2f;
	ACCEKF_init(sensor);
	MAGEKF_init(sensor);
	EYE_init();
}
/*******************************************************************
��Ԫ������
float* quat : ������Ԫ��
float* q_matrix �������Ԫ������
int mode ������ģʽ[1:Ŀ����Ԫ���ҳˣ�2��Ŀ����Ԫ�����]
int matT ��ת��[0����ת�ã�1��ת��]
�ҳˣ�q_other*quat
��ˣ�quat*q_other
********************************************************************/
static void w_matrix(float* quat, float* q_matrix, int mode, int matT)
{
	if (mode == 1) {
		if (matT == 1) {
			q_matrix[0] = quat[0]; q_matrix[1] = quat[1]; q_matrix[2] = quat[2]; q_matrix[3] = quat[3];
			q_matrix[4] = -quat[1]; q_matrix[5] = quat[0]; q_matrix[6] = -quat[3]; q_matrix[7] = quat[2];
			q_matrix[8] = -quat[2]; q_matrix[9] = quat[3]; q_matrix[10] = quat[0]; q_matrix[11] = -quat[1];
			q_matrix[12] = -quat[3]; q_matrix[13] = -quat[2]; q_matrix[14] = quat[1]; q_matrix[15] = quat[0];
		}
		else {
			q_matrix[0] = quat[0]; q_matrix[1] = -quat[1]; q_matrix[2] = -quat[2]; q_matrix[3] = -quat[3];
			q_matrix[4] = quat[1]; q_matrix[5] = quat[0]; q_matrix[6] = quat[3]; q_matrix[7] = -quat[2];
			q_matrix[8] = quat[2]; q_matrix[9] = -quat[3]; q_matrix[10] = quat[0]; q_matrix[11] = quat[1];
			q_matrix[12] = quat[3]; q_matrix[13] = quat[2]; q_matrix[14] = -quat[1]; q_matrix[15] = quat[0];
		}
	}
	else
	{
		if (matT == 1) {
			q_matrix[0] = quat[0]; q_matrix[1] = quat[1]; q_matrix[2] = quat[2]; q_matrix[3] = quat[3];
			q_matrix[4] = -quat[1]; q_matrix[5] = quat[0]; q_matrix[6] = quat[3]; q_matrix[7] = -quat[2];
			q_matrix[8] = -quat[2]; q_matrix[9] = -quat[3]; q_matrix[10] = quat[0]; q_matrix[11] = quat[1];
			q_matrix[12] = -quat[3]; q_matrix[13] = quat[2]; q_matrix[14] = -quat[1]; q_matrix[15] = quat[0];
		}
		else {
			q_matrix[0] = quat[0]; q_matrix[1] = -quat[1]; q_matrix[2] = -quat[2]; q_matrix[3] = -quat[3];
			q_matrix[4] = quat[1]; q_matrix[5] = quat[0]; q_matrix[6] = -quat[3]; q_matrix[7] = quat[2];
			q_matrix[8] = quat[2]; q_matrix[9] = quat[3]; q_matrix[10] = quat[0]; q_matrix[11] = -quat[1];
			q_matrix[12] = quat[3]; q_matrix[13] = -quat[2]; q_matrix[14] = quat[1]; q_matrix[15] = quat[0];
		}
	}
}
/*******************************************************************
�Ÿ�������ֵ:{0:OK,2.1:init failed,-2.1:useless mag}
********************************************************************/
static float EnvironmentMagStatus[sensors] = { 0 }; //
/*******************************************************************
���ٻع�״̬:{2.1:״̬1,-2.1:״̬2}
********************************************************************/
static float RecoverSignalEKF[sensors] = { 2.1 };
/*******************************************************************
���ٻع�:{0:no,1:yes}
********************************************************************/
static char sensorQuitReturnCtrl[sensors] = { 0 }; //

void EKF_EnableSensorQuitReturn(void)
{
	for (char i = 0; i < sensors; i++) {
		sensorQuitReturnCtrl[i] = 0x01;
	}
}
/*******************************************************************
�ų��ں�ģʽ����ֵ:{1:use absolute mag,2:only relative mag,3:no mag}
********************************************************************/
static int MagModelStatus = 1; //
void EKF_ChangeMagModel(int modelsign)
{
	if ((modelsign > 0) && (modelsign <= 3)) {
		MagModelStatus = modelsign;
		if (modelsign == 2){
			for (char i = 0; i < sensors; i++) {
				jiaomThresold[i] = 0.15;
				jiaommagThresold[i] = 0.08;
			}
		}
		else{
			for (char i = 0; i < sensors; i++) {
				jiaomThresold[i] = 0.15;
				jiaommagThresold[i] = 0.08;
			}
		}
	}
	else {
		MagModelStatus = 1;
		for (char i = 0; i < sensors; i++) {
				jiaomThresold[i] = 0.15;
				jiaommagThresold[i] = 0.08;
			}
	}
}
/*******************************************************************
�����˶�ģʽ����ֵ:{1:Ĭ���㷨,2:����ģʽ }
********************************************************************/
static int SpecialModelStatus = 1; //
void EKF_ChangeSpecialModel(int modelsign)
{
	if ((modelsign > 0) && (modelsign <= 2)) {
		SpecialModelStatus = modelsign;
	}
	else {
		SpecialModelStatus = 1;
	}
}

/*******************************************************************
���ٻع�����ֵ:{0:�������ٻع��жϣ��ɰ汾��,   2.1,-2.1:���ٻع���ɱ�־λ��������ֵ�仯ʱ�ͷ����仯��������ֵ�ڱ仯}
********************************************************************/
static float sensorQuitReturnState[sensors] = {-2.1};

static bool sensorQuitTimeReturnCtrl[sensors] = { false };

static void Print(float* mat, char r, char c)
{
	printf("=[ ");
	char i, j;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%f ",mat[i * c + j]);
		}
		printf(";");
	}
	printf("]\n");
}
/*******************************************************************
* @brief  KalmanFilter()
* @param  acc	- 3_Axis acceleration sensor data input
* @param  gyr - 3_Axis gyroscope sensor data input
* @param  mag - 3_Axis Magnetometer  sensor data input
********************************************************************/
static float t_a[sensors], t_m[sensors] ,t_quit[sensors];
static float quat_EKF[sensors][4], quat_Filter[sensors][4];
static int gyr_vec_flag[sensors],count[sensors];
uint8_t KalmanFilter(float* acc_mcu, float* gyr_mcu, float* mag_mcu, float dtTime, float* q_out)
{
	char sensor = 0;
	float acc[3] = { acc_mcu[0], acc_mcu[1], acc_mcu[2] }, gyr[3] = { gyr_mcu[0], gyr_mcu[1], gyr_mcu[2] }, mag[3] = { mag_mcu[0], mag_mcu[1], mag_mcu[2] };
	float acc_EKF[3], mag_EKF[3];
	float accErr, gyrErr, g = 9.8;
	float q_temp[4], q_temp2[4], acc_T[3], P_temp[16], X_temp[3];
	float k_a, k_m, float_temp, jiao_acc, jiaom_mag, jiaom, Ryu, bx, by, bz;
	float dist_ACC1, dist_ACC2, dist_ACC3;
	float mid1[36], mid2[36], mid3[36], mid4[36], mid5[36], PRY[3], A[16], H1[12], K1[12], H2[12], K2[12];
	float A_ACC[9];
	float Cbn[9], m_n[3],m_n2[3];
	char acc_update = 0;
	if ((acc[0] == 0 && acc[1] == 0 && acc[2] == 0) || (mag[0] == 0 && mag[1] == 0 && mag[2] == 0))
	{
		return 0;
	}
	float mag0_s, mag0_ss, acc0_s, acc0_ss, gyr0_s, mag0_s_EKF, mag0_ss_EKF;
	mag0_s = mag[0] * mag[0] + mag[1] * mag[1] + mag[2] * mag[2];
	mag0_ss = sqrtf(mag0_s);
	acc0_s = acc[0] * acc[0] + acc[1] * acc[1] + acc[2] * acc[2];
	acc0_ss = sqrtf(acc0_s);
	gyr0_s = gyr[0] * gyr[0] + gyr[1] * gyr[1] + gyr[2] * gyr[2];
	gyrErr = sqrtf(gyr0_s);
	accErr = fabsf(acc0_ss - g);
	if (acc0_ss != 0) {
		acc[0] = acc[0] / acc0_ss;
		acc[1] = acc[1] / acc0_ss;
		acc[2] = acc[2] / acc0_ss;
	}
	if (mag0_s != 0) {
		mag[0] = mag[0] / mag0_ss;
		mag[1] = mag[1] / mag0_ss;
		mag[2] = mag[2] / mag0_ss;
	}
	if (k_first[sensor] <= 0.1f)
	{
		if ((acc[0] == 0 && acc[1] == 0 && acc[2] == 0) || (mag[0] == 0 && mag[1] == 0 && mag[2] == 0))
		{
			return 0;
		}
		if (accErr < 0.5f && gyrErr < 0.5f)
		{
			k_first[sensor] += dtTime;
		}
		else {
			k_first[sensor] = 0;
			InitNumber[sensor] = 1;
			MAG_Fa0[sensor][0] = 0;
			MAG_Fa0[sensor][1] = 0;
			MAG_Fa0[sensor][2] = 0;
			MeanACC[sensor][0] = 0; //��ʼ��֡ACC��ֵ
			MeanACC[sensor][1] = 0;
			MeanACC[sensor][2] = 0;
			MeanMAG[sensor][0] = 0; //��ʼ��֡��ʼ��֡MAG��ֵ��ֵ
			MeanMAG[sensor][1] = 0;
			MeanMAG[sensor][2] = 0;
			MAG_InitialModule[sensor] = 0;
		}
		ekf_init(sensor);

		for (int i = 0; i < 3; i++) {
			MeanACC[sensor][i] = ((InitNumber[sensor] - 1)*MeanACC[sensor][i] + acc[i]) / InitNumber[sensor];
			MeanMAG[sensor][i] = ((InitNumber[sensor] - 1)*MeanMAG[sensor][i] + mag[i]) / InitNumber[sensor];
			MAG_InitialModule[sensor] = ((InitNumber[sensor] - 1)*MAG_InitialModule[sensor] + mag0_ss) / InitNumber[sensor];
		}
		Copy(X_ACC_EKF[sensor], acc_mcu, 3);
		X_MAG_EKF[sensor][0] = mag_mcu[0];
		X_MAG_EKF[sensor][1] = mag_mcu[1];
		X_MAG_EKF[sensor][2] = mag_mcu[2];
		X_MAG_EKF[sensor][3] = 0;
		X_MAG_EKF[sensor][4] = 0;
		X_MAG_EKF[sensor][5] = 0;

		PRY[0] = atan2f(MeanACC[sensor][1], MeanACC[sensor][2]);
		PRY[1] = atan2f(-MeanACC[sensor][0], sqrtf(MeanACC[sensor][1] * MeanACC[sensor][1] + MeanACC[sensor][2] * MeanACC[sensor][2]));
		PRY[2] = atan2f((MeanMAG[sensor][2] * sinf(PRY[0]) - MeanMAG[sensor][1] * cosf(PRY[0])),
			(MeanMAG[sensor][0] * cosf(PRY[1]) + (MeanMAG[sensor][1] * sinf(PRY[0]) + MeanMAG[sensor][2] * cosf(PRY[0])) * sinf(PRY[1])));
		quat_EKF[sensor][0] = cosf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) + sinf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
		quat_EKF[sensor][1] = sinf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) - cosf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
		quat_EKF[sensor][2] = cosf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) + sinf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
		quat_EKF[sensor][3] = cosf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]) - sinf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]);

		matrix_Cbn(quat_EKF[sensor], Cbn);
		matrix_mul(Cbn, 3, 3, MeanMAG[sensor], 1, m_n);
		bx = sqrtf(m_n[0] * m_n[0] + m_n[1] * m_n[1]);
		by = 0;
		bz = m_n[2];

		MAG_Fa0[sensor][0] = bx;
		MAG_Fa0[sensor][1] = by;
		MAG_Fa0[sensor][2] = bz;

		float_temp = Module(MAG_Fa0[sensor], 3);
		for (int i = 0; i < 3; i++) {
			MAG_Fa0[sensor][i] /= float_temp;
			MAG_MO0[sensor][i] = MAG_Fa0[sensor][i];
			MAG_Fam[sensor][i] = MAG_Fa0[sensor][i];
			MAG_MOm[sensor][i] = m_n[i];
		}
		MAG_Z0[sensor] = bz;
		MAG_LastTrue[sensor] = 1;

		Copy(quat_Filter[sensor], quat_EKF[sensor], 4);
		Copy(q_out, quat_EKF[sensor], 4);

		t_a[sensor] = 0.005 * sensor;
		t_m[sensor] = 0.005 * sensor + 0.015;

		InitNumber[sensor]++;

		EnvironmentMagStatus[sensor] = 2.1;

//		gyrStatic[sensor] = 0;
//		accStatic[sensor] = 0;
		Copy(accLast[sensor], acc_mcu, 3);
		//FastMovementTime[sensor] = 0;
		QuitReturnCtrlNumber[sensor] = 0;
		QuickRecover[sensor] = 0;

		q_out[0] += EnvironmentMagStatus[sensor];
//		restore_flag[sensor] = 0;
//		recount[sensor] = 0;
//		jiaom_thresold = 0.15f;
//		jiaom_mag_thresold = 0.08f;
		return 1;
	}

	if (gyrErr > 0.05f && dtTime < 0.01f) {
		//ACC
		A_ACC[0] = 1; A_ACC[1] = -gyr[2] * dtTime; A_ACC[2] = gyr[1] * dtTime;
		A_ACC[3] = gyr[2] * dtTime; A_ACC[4] = 1; A_ACC[5] = -gyr[0] * dtTime;
		A_ACC[6] = -gyr[1] * dtTime; A_ACC[7] = gyr[0] * dtTime; A_ACC[8] = 1;
		matrix_mul(X_ACC_EKF[sensor], 1, 3, A_ACC, 3, X_temp);
		Copy(X_ACC_EKF[sensor], X_temp, 3);
		matrix_trans(A_ACC, 3, 3, mid1);
		matrix_mul(mid1, 3, 3, P_ACC_EKF[sensor], 3, mid2);
		matrix_mul(mid2, 3, 3, A_ACC, 3, mid3);
		matrix_add(mid3, Q_ACC_EKF[sensor], 3, 3, P_ACC_EKF[sensor]);

		//MAG
		gyr_vec_flag[sensor] = 0;
		A_MAG_EKF[sensor][0] = A_ACC[0];
		A_MAG_EKF[sensor][1] = A_ACC[1];
		A_MAG_EKF[sensor][2] = A_ACC[2];
		A_MAG_EKF[sensor][6] = A_ACC[3];
		A_MAG_EKF[sensor][7] = A_ACC[4];
		A_MAG_EKF[sensor][8] = A_ACC[5];
		A_MAG_EKF[sensor][12] = A_ACC[6];
		A_MAG_EKF[sensor][13] = A_ACC[7];
		A_MAG_EKF[sensor][14] = A_ACC[8];
		matrix_mul(X_MAG_EKF[sensor], 1, 3, A_ACC, 3, X_temp);
		Copy(X_MAG_EKF[sensor], X_temp, 3);
		matrix_trans(A_MAG_EKF[sensor], 6, 6, mid1);
		matrix_mul(mid1, 6, 6, P_MAG_EKF[sensor], 6, mid2);
		matrix_mul(mid2, 6, 6, A_MAG_EKF[sensor], 6, mid3);
		matrix_add(mid3, Q_MAG_EKF[sensor], 6, 6, P_MAG_EKF[sensor]);
		//Quat
		A[0] = 1; A[1] = -0.5f * gyr[0] * dtTime; A[2] = -0.5f * gyr[1] * dtTime; A[3] = -0.5f * gyr[2] * dtTime;
		A[4] = 0.5f * gyr[0] * dtTime; A[5] = 1; A[6] = 0.5f * gyr[2] * dtTime; A[7] = -0.5f * gyr[1] * dtTime;
		A[8] = 0.5f * gyr[1] * dtTime; A[9] = -0.5f * gyr[2] * dtTime; A[10] = 1; A[11] = 0.5f * gyr[0] * dtTime;
		A[12] = 0.5f * gyr[2] * dtTime; A[13] = 0.5f * gyr[1] * dtTime; A[14] = -0.5f * gyr[0] * dtTime; A[15] = 1;
		matrix_mul(A, 4, 4, quat_EKF[sensor], 1, q_temp);  //quat_EKF(4,1,k)=A(4,4,k)*quat_EKF(4,1,k-1);
		Copy(quat_EKF[sensor], q_temp, 4);
		if (Norm(quat_EKF[sensor], 4) == 0) { return 0; }

		matrix_mul(A, 4, 4, quat_Filter[sensor], 1, q_temp);  //quat_Filter(4,1,k)=A(4,4,k)*quat_Filter(4,1,k-1);
		Copy(quat_Filter[sensor], q_temp, 4);
		if (Norm(quat_Filter[sensor], 4) == 0) { return 0; }

		matrix_4_mul(A, P_EKF[sensor], mid1);
		matrix_trans(A, 4, 4, mid2);
		matrix_4_mul(mid1, mid2, mid3);
		matrix_add(mid3, Q_GYR[sensor], 4, 4, P_EKF[sensor]);  //P_EKF(4,4,k)=A(4,4,k) * P_EKF(4,4,k-1) * A(4,4,k)'+Q_GYR(4,4);

		float_temp = 100;
		for (char i = 0; i < 16; i++) {
			if (P_EKF[sensor][i] > float_temp) {
				P_EKF[sensor][i] = float_temp;
			}
			else if (P_EKF[sensor][i] < -float_temp) {
				P_EKF[sensor][i] = -float_temp;
			}
		}
	}
	t_a[sensor] = t_a[sensor] + dtTime;
//	float accDF[3];
	float maxErr;
	float K_ACC[9];
	if (t_a[sensor] > 0.03f&&1)
	{
		t_a[sensor] = t_a[sensor] - 0.03f;

		acc_update = 1;
		Copy(accLast[sensor], acc_mcu, 3);

		//ACC EKF
			if (accErr < 2.f) {
			float_temp = gyrErr * accErr + 1e-4;
			maxErr = fmaxf(float_temp, ERR_ACC_EKF[sensor]);
			Copy(mid1, R_ACC_EKF[sensor], 9);
			mid1[0] *= maxErr;
			mid1[4] *= maxErr;
			mid1[8] *= maxErr;
			matrix_add(P_ACC_EKF[sensor], mid1, 3, 3, mid2);
			matrix_3_inv(mid2, mid3);
			matrix_mul(P_ACC_EKF[sensor], 3, 3, mid3, 3, K_ACC);
			ERR_ACC_EKF[sensor] = float_temp;
			mid1[0] = acc_mcu[0] - X_ACC_EKF[sensor][0];
			mid1[1] = acc_mcu[1] - X_ACC_EKF[sensor][1];
			mid1[2] = acc_mcu[2] - X_ACC_EKF[sensor][2];
			matrix_mul(K_ACC, 3, 3, mid1, 1, mid2);
			matrix_add(X_ACC_EKF[sensor], mid2, 3, 1, mid3);
			Copy(X_ACC_EKF[sensor], mid3, 3);
			matrix_sub(eye3, K_ACC, 3, 3, mid1);
			matrix_mul(mid1, 3, 3, P_ACC_EKF[sensor], 3, P_temp);
			Copy(P_ACC_EKF[sensor], P_temp, 9);
			}
		Copy(acc_EKF, X_ACC_EKF[sensor], 3);
//			Copy(acc_EKF, acc_mcu[sensor], 3);
		Norm(acc_EKF, 3);

	}
	//float StaticState = (gyrStatic[sensor] + accStatic[sensor])*0.5;
	acc_T[0] = 2 * (quat_EKF[sensor][1] * quat_EKF[sensor][3] - quat_EKF[sensor][0] * quat_EKF[sensor][2]);
	acc_T[1] = 2 * (quat_EKF[sensor][2] * quat_EKF[sensor][3] + quat_EKF[sensor][0] * quat_EKF[sensor][1]);
	acc_T[2] = quat_EKF[sensor][0] * quat_EKF[sensor][0] - quat_EKF[sensor][1] * quat_EKF[sensor][1] - quat_EKF[sensor][2] * quat_EKF[sensor][2] + quat_EKF[sensor][3] * quat_EKF[sensor][3];
	if (acc0_ss > 0) {
		jiao_acc = ACos(acc_EKF[0] * acc_T[0] + acc_EKF[1] * acc_T[1] + acc_EKF[2] * acc_T[2]);
	}
	else {
		jiao_acc = 100;
	}
	//float gyrBei = gyrErr / 20.0;
	//if (gyrBei < 1)
	//	gyrBei = 1;

		//���ٻع�
	if ((acc_update == 1) || (sensorQuitReturnCtrl[sensor] == 1)) {
		if (accErr > 10 && gyrErr > 10) {
			QuitReturnCtrlNumber[sensor] += 0.1f;
		}
		else if (accErr < 0.8f && gyrErr < 0.5f) {
			if (jiao_acc > 0.4f) {
				QuitReturnCtrlNumber[sensor] += 0.1f;
			}
			else {
				QuitReturnCtrlNumber[sensor] -= 0.02f;
			}
		}
		else if (accErr < 2 && gyrErr < 1) {
			QuitReturnCtrlNumber[sensor] -= 0.02f;
		}
		if (QuitReturnCtrlNumber[sensor] < 0) {
				QuitReturnCtrlNumber[sensor] = 0;
			}
		if ((QuitReturnCtrlNumber[sensor] > 10 || sensorQuitReturnCtrl[sensor] == 1) && accErr < 0.8f && gyrErr < 0.5f) {//���ٻع�
			QuickRecover[sensor] = 1;
		}
	}
;
	if (acc_update)
	{
		if (((accErr < 1.0f) && (gyrErr < 1.0f) && (jiao_acc < 0.5f)) || ((accErr < 0.5f) && (gyrErr < 0.2f))) {
			//Copy(acc_EKF, acc, 3);

			if ((accErr < 0.2f) && (gyrErr < 0.2f)) {
				k_a = 1 + 10 * fabsf(acc0_s - g * g);
			}
			else if ((accErr < 0.5f) && (gyrErr < 0.5f)) {
				k_a = 1 + 50 * fabsf(acc0_s - g * g);
			}
			else {
				k_a = 1 + 100 * fabsf(acc0_s - g * g) * (1 + jiao_acc * 20);
			}
//			if ((accErr < 0.2f) && (gyrErr < 0.2f)) {
//				k_a = 0.1+10 * fabsf(acc0_s - g * g);
//			}
//			else if ((accErr < 0.5f) && (gyrErr < 0.5f)) {
//				k_a = 0.5 + 50 * fabsf(acc0_s - g * g);
//			}
//			else {
//				k_a = 1 + 100 * fabsf(acc0_s - g * g) * (1 + jiao_acc * 20);
//			}
			Racc_use[sensor][0] = k_a * Racc_static[sensor][0];
			Racc_use[sensor][4] = k_a * Racc_static[sensor][4];
			Racc_use[sensor][8] = k_a * Racc_static[sensor][8];

			H1[0] = -quat_EKF[sensor][2] * 2; H1[1] = quat_EKF[sensor][3] * 2; H1[2] = -quat_EKF[sensor][0] * 2; H1[3] = quat_EKF[sensor][1] * 2;
			H1[4] = quat_EKF[sensor][1] * 2; H1[5] = quat_EKF[sensor][0] * 2; H1[6] = quat_EKF[sensor][3] * 2; H1[7] = quat_EKF[sensor][2] * 2;
			H1[8] = quat_EKF[sensor][0] * 2; H1[9] = -quat_EKF[sensor][1] * 2; H1[10] = -quat_EKF[sensor][2] * 2; H1[11] = quat_EKF[sensor][3] * 2;
			matrix_mul(H1, 3, 4, P_EKF[sensor], 4, mid1);
			matrix_trans(H1, 3, 4, mid2);
			matrix_mul(mid1, 3, 4, mid2, 3, mid3);
			matrix_add(mid3, Racc_use[sensor], 3, 3, mid1);
			matrix_3_inv(mid1, mid3);
			matrix_mul(P_EKF[sensor], 4, 4, mid2, 3, mid1);
			matrix_mul(mid1, 4, 3, mid3, 3, K1);   //K1(4,3,k)=P_EKF(4,4,k)*H1(3,4,k)'/(H1(3,4,k)*P_EKF(4,4,k)*H1(3,4,k)'+Racc_use(3,3,k));

			mid1[0] = acc_EKF[0] - acc_T[0];
			mid1[1] = acc_EKF[1] - acc_T[1];
			mid1[2] = acc_EKF[2] - acc_T[2];
			dist_ACC1= mid1[0] * mid1[0] + mid1[1] * mid1[1] + mid1[2] * mid1[2]; 
			float_temp = sqrtf(mid1[0] * mid1[0] + mid1[1] * mid1[1] + mid1[2] * mid1[2]);//�޸����ȹ�ϵ float_temp=2Rsin(Q_GYR/2),1��Ӧÿ֡5.8�ȵ��޸���
			Ryu = 0.08;
			if (float_temp > Ryu) {
				mid1[0] = mid1[0] * Ryu / float_temp;
				mid1[1] = mid1[1] * Ryu / float_temp;
				mid1[2] = mid1[2] * Ryu / float_temp;
			}
			matrix_mul(K1, 4, 3, mid1, 1, mid2);
			matrix_add(quat_EKF[sensor], mid2, 4, 1, q_temp);     //quat_EKF(4,1,k)=quat_EKF(4,1,k)+K1(4,3,k)*(a(3,1,k)-Ha(3,1,k));
			if (Norm(q_temp, 4) == 0) { return 0; }
			acc_T[0] = 2 * (q_temp[1] * q_temp[3] - q_temp[0] * q_temp[2]);
			acc_T[1] = 2 * (q_temp[2] * q_temp[3] + q_temp[0] * q_temp[1]);
			acc_T[2] = q_temp[0] * q_temp[0] - q_temp[1] * q_temp[1] - q_temp[2] * q_temp[2] + q_temp[3] * q_temp[3];
			mid1[0] = acc_EKF[0] - acc_T[0];
			mid1[1] = acc_EKF[1] - acc_T[1];
			mid1[2] = acc_EKF[2] - acc_T[2];
			dist_ACC2 = mid1[0] * mid1[0] + mid1[1] * mid1[1] + mid1[2] * mid1[2];

			matrix_sub(quat_EKF[sensor], mid2, 4, 1, q_temp2);     //quat_EKF(4,1,k)=quat_EKF(4,1,k)-K1(4,3,k)*(a(3,1,k)-Ha(3,1,k));
			if (Norm(q_temp2, 4) == 0) { return 0; }
			acc_T[0] = 2 * (q_temp2[1] * q_temp2[3] - q_temp2[0] * q_temp2[2]);
			acc_T[1] = 2 * (q_temp2[2] * q_temp2[3] + q_temp2[0] * q_temp2[1]);
			acc_T[2] = q_temp2[0] * q_temp2[0] - q_temp2[1] * q_temp2[1] - q_temp2[2] * q_temp2[2] + q_temp2[3] * q_temp2[3];
			mid1[0] = acc_EKF[0] - acc_T[0];
			mid1[1] = acc_EKF[1] - acc_T[1];
			mid1[2] = acc_EKF[2] - acc_T[2];
			dist_ACC3 = mid1[0] * mid1[0] + mid1[1] * mid1[1] + mid1[2] * mid1[2];
			if (dist_ACC2 <= dist_ACC3) {
				if (dist_ACC1 > dist_ACC2) {
					Copy(quat_EKF[sensor], q_temp, 4);
					matrix_mul(K1, 4, 3, H1, 4, mid1);
					matrix_sub(eye4, mid1, 4, 4, mid2);
					matrix_4_mul(mid2, P_EKF[sensor], P_temp);  //P2(4,4,k)=(eye(4)-K1(4,3,k)*H1(3,4,k))*P_EKF(4,4,k);	
					Copy(P_EKF[sensor], P_temp, 16);
				}
			}
			else {
				if (dist_ACC1 > dist_ACC3) {
					Copy(quat_EKF[sensor], q_temp2, 4);
					matrix_mul(K1, 4, 3, H1, 4, mid1);
					matrix_add(eye4, mid1, 4, 4, mid2);
					matrix_4_mul(mid2, P_EKF[sensor], P_temp);  //P2(4,4,k)=(eye(4)+K1(4,3,k)*H1(3,4,k))*P_EKF(4,4,k);	
					Copy(P_EKF[sensor], P_temp, 16);
				}

			}
		}
	}

	float K_MAG_EKF[18];
	float jiao_error[3];
	float jiao0, jiao_mag,jiao0_2, jiao_mag_2, MAG_MO[3];
	t_m[sensor] = t_m[sensor] + dtTime;
	int flagg = 1;
  if (MagModelStatus == 2){flagg = 0;}
	if (t_m[sensor] > 0.03f&&flagg&&1)
	{
		if(gyrErr > 0.05f){
			matrix_Cbn(quat_EKF[sensor], Cbn);
			matrix_mul(Cbn, 3, 3, mag, 1, m_n2);
			float bx2 = sqrtf(m_n2[0] * m_n2[0] + m_n2[1] * m_n2[1]);
			float bz2 = m_n2[2];
			float Fam2[3] = { bx2,0,bz2 };
			jiao_mag_2 = fabsf(atan2f(m_n2[1], m_n2[0]));
			jiao0_2 = ACos(Fam2[0] * MAG_Fa0[sensor][0] + Fam2[2] * MAG_Fa0[sensor][2]);

			 k_m = 1;
				

			t_m[sensor] = t_m[sensor] - 0.03f;
			//MAG EKF
			gyr_vec_flag[sensor] += 1;
			if(gyr_vec_flag[sensor]<=2){ 
			Rmag_use[sensor][0] = k_m * R_MAG_EKF[sensor][0];
			Rmag_use[sensor][4] = k_m * R_MAG_EKF[sensor][4];
			Rmag_use[sensor][8] = k_m * R_MAG_EKF[sensor][8];
			matrix_trans(H_MAG_EKF[sensor], 6, 3, mid1);
			matrix_mul(mid1, 3, 6, P_MAG_EKF[sensor], 6, mid2);
			matrix_mul(mid2, 3, 6, H_MAG_EKF[sensor], 3, mid3);
			matrix_add(mid3, Rmag_use[sensor], 3, 3, mid1);
			matrix_3_inv(mid1, mid2);
			matrix_mul(P_MAG_EKF[sensor], 6, 6, H_MAG_EKF[sensor], 3, mid1);
			matrix_mul(mid1, 6, 3, mid2, 3, K_MAG_EKF);
			matrix_mul(X_MAG_EKF[sensor], 1, 6, H_MAG_EKF[sensor], 3, mid1);
			mid2[0] = mag_mcu[0] - mid1[0];
			mid2[1] = mag_mcu[1] - mid1[1];
			mid2[2] = mag_mcu[2] - mid1[2];
			matrix_mul(K_MAG_EKF, 6, 3, mid2, 1, mid1);
			matrix_add(X_MAG_EKF[sensor], mid1, 1, 6, mid2);
			Copy(X_MAG_EKF[sensor], mid2, 6);
			matrix_trans(H_MAG_EKF[sensor], 6, 3, mid1);
			matrix_mul(K_MAG_EKF, 6, 3, mid1, 6, mid2);
			matrix_sub(eye6, mid2, 6, 6, mid3);
			matrix_mul(mid3, 6, 6, P_MAG_EKF[sensor], 6, mid1);
			Copy(P_MAG_EKF[sensor], mid1, 36);
		}
			////////////////////////////////////
			Copy(mag_EKF, X_MAG_EKF[sensor], 3);
			
			////////////////////////////////////
			mag0_s_EKF = mag_EKF[0] * mag_EKF[0] + mag_EKF[1] * mag_EKF[1] + mag_EKF[2] * mag_EKF[2];
			mag0_ss_EKF = sqrtf(mag0_s_EKF);

			Norm(mag_EKF, 3);
			

			/*mag0_ss_EKF = mag0_ss;
			Copy(mag_EKF, mag, 3);*/

			//matrix_Cbn(quat_EKF[sensor], Cbn);
			matrix_mul(Cbn, 3, 3, mag_EKF, 1, m_n);
	//		matrix_mul(Cbn, 3, 3, mag, 1, m_n2);
			bx = sqrtf(m_n[0] * m_n[0] + m_n[1] * m_n[1]);
			bz = m_n[2];
			
			float Fam[3] = { bx,0,bz };
			
			jiao0 = ACos(Fam[0] * MAG_Fa0[sensor][0] + Fam[2] * MAG_Fa0[sensor][2]);
			jiao_mag = fabsf(atan2f(m_n[1], m_n[0]));
			char FixMAG = 0;
			
			if ((mag0_ss < 0.50f) && (mag0_ss > 0.15f)) {
				EnvironmentMagStatus[sensor] = 0;//��ȫ
			}
			else {
				EnvironmentMagStatus[sensor] = -2.1; //Ƶ�����ڱ�ʾ�ų�ת��Ƶ��
			}
			if (((((jiao0_2 < 0.18f) && (jiao_mag_2 < 0.15f) && (fabsf(bz2 - MAG_Z0[sensor]) < 0.08f) && fabsf(mag0_ss - MAG_InitialModule[sensor]) < 0.08f)) || ((jiao0_2 < 0.1f) && (fabsf(bz2 - MAG_Z0[sensor]) < 0.05f) && (fabsf(mag0_ss - MAG_InitialModule[sensor]) < 0.05f)))&& (mag0_ss < 0.50f) && (mag0_ss > 0.15f) && MagModelStatus == 1) {
			
			if(MAG_LastTrue[sensor]==0){
					for (int i = 0; i < 36; i++)
					{
						P_MAG_EKF[sensor][i] = 0;		
					}
					P_MAG_EKF[sensor][0] = 1e-3f; P_MAG_EKF[sensor][7] = 1e-3f; P_MAG_EKF[sensor][14] = 1e-3f;
					P_MAG_EKF[sensor][21] = 1e-3f; P_MAG_EKF[sensor][28] = 1e-3f; P_MAG_EKF[sensor][35] = 1e-3f;
				}
				MAG_LastTrue[sensor] = 1;
				FixMAG = 1;
				Copy(MAG_MO, MAG_MO0[sensor], 3);
	/*********************************************new part***************************************************/
	//			jiao_error[0] = MAG_MO0[sensor][1] * m_n[2] - MAG_MO0[sensor][2] * m_n[1];
	//			jiao_error[1] = MAG_MO0[sensor][2] * m_n[0] - MAG_MO0[sensor][0] * m_n[2];
	//			jiao_error[2] = MAG_MO0[sensor][0] * m_n[1] - MAG_MO0[sensor][1] * m_n[0];
	//			k_m = 1 + 50 * fabsf(mag0_s - MAG_InitialModule[sensor] * MAG_InitialModule[sensor]) + 50 * fabsf(sqrtf(jiao_error[0] * jiao_error[0] + jiao_error[1] * jiao_error[1] + jiao_error[2] * jiao_error[2]));
	/********************************************************************************************************/			
				k_m = 1 + 50 * fabsf(mag0_s - MAG_InitialModule[sensor] * MAG_InitialModule[sensor]);
				X_MAG_EKF[sensor][3] = 0;
				X_MAG_EKF[sensor][4] = 0;
				X_MAG_EKF[sensor][5] = 0;
//				EnvironmentMagStatus[sensor] = 0;
			}
			else {
				if (MagModelStatus == 1 || MagModelStatus == 2) {
					if (MAG_LastTrue[sensor] == 1) {
//						MAG_Change[sensor] = 1;
						MAG_LastTrue[sensor] = 0;
						////////////////////////////////////
						Copy(MAG_MOm[sensor], m_n, 3);
						Copy(MAG_Fam[sensor], Fam, 3);
						////////////////////////////////////
						Copy(MAG_OMOm[sensor], m_n2, 3);
						Copy(MAG_OFam[sensor], Fam2, 3);
						MAG_Zm[sensor] = bz2;
						for (int i = 0; i < 3; i++) {
							P_mag_ekf_temp[sensor][i] = P_MAG_EKF[sensor][i];
							P_mag_ekf_temp[sensor][i+3] = P_MAG_EKF[sensor][i+6];
							P_mag_ekf_temp[sensor][i+6] = P_MAG_EKF[sensor][i+12];
						}
						X_MAG_EKF[sensor][0] = mag_mcu[0];
						X_MAG_EKF[sensor][1] = mag_mcu[1];
						X_MAG_EKF[sensor][2] = mag_mcu[2];
						X_MAG_EKF[sensor][3] = 0;
						X_MAG_EKF[sensor][4] = 0;
						X_MAG_EKF[sensor][5] = 0;
						for (int i = 0; i < 36; i++)
						{
							P_MAG_EKF[sensor][i] = 0;		
						}
						P_MAG_EKF[sensor][0] = 1e-3f; P_MAG_EKF[sensor][7] = 1e-3f; P_MAG_EKF[sensor][14] = 1e-3f;
						P_MAG_EKF[sensor][21] = 1e-3f; P_MAG_EKF[sensor][28] = 1e-3f; P_MAG_EKF[sensor][35] = 1e-3f;
						MAG_InitialModule_m[sensor] = mag0_ss_EKF;
//						EnvironmentMagStatus[sensor] = -2.1;
					}
					else {
						
						jiaom = fabsf(ACos(Fam[0] * MAG_Fam[sensor][0] + Fam[2] * MAG_Fam[sensor][2]));
						jiaom_mag = fabsf(ACos((m_n[0] * MAG_MOm[sensor][0] + m_n[1] * MAG_MOm[sensor][1]) / (Fam[0] * sqrtf(MAG_MOm[sensor][0] * MAG_MOm[sensor][0] + MAG_MOm[sensor][1] * MAG_MOm[sensor][1]))));
//						jiaom = fabsf(ACos(Fam2[0] * MAG_OFam[sensor][0] + Fam2[2] * MAG_OFam[sensor][2]));
//						jiaom_mag = fabsf(ACos((m_n2[0] * MAG_OMOm[sensor][0] + m_n2[1] * MAG_OMOm[sensor][1]) / (Fam2[0] * sqrtf(MAG_OMOm[sensor][0] * MAG_OMOm[sensor][0] + MAG_OMOm[sensor][1] * MAG_OMOm[sensor][1]))));
						
						if ((jiaom < jiaomThresold[sensor]) && (jiaom_mag < jiaommagThresold[sensor]) && (fabsf(bz2 - MAG_Zm[sensor]) < 0.1f) && fabsf(mag0_ss_EKF - MAG_InitialModule_m[sensor]) < 0.1f) {
							FixMAG = 1;
						
							Copy(MAG_MO, MAG_MOm[sensor], 3);
	/*********************************************new part***************************************************/					
	//						jiao_error[0] = MAG_MOm[sensor][1] * m_n[2] - MAG_MOm[sensor][2] * m_n[1];
	//						jiao_error[1] = MAG_MOm[sensor][2] * m_n[0] - MAG_MOm[sensor][0] * m_n[2];
	//						jiao_error[2] = MAG_MOm[sensor][0] * m_n[1] - MAG_MOm[sensor][1] * m_n[0];
	//						k_m = 1 + 50 * fabsf(mag0_s - MAG_InitialModule_m[sensor] * MAG_InitialModule_m[sensor]) + 50 * fabsf(sqrtf(jiao_error[0] * jiao_error[0] + jiao_error[1] * jiao_error[1] + jiao_error[2] * jiao_error[2]));
	/*********************************************new part***************************************************/						
							k_m = 1 + 50 * fabsf(mag0_s_EKF - MAG_InitialModule_m[sensor] * MAG_InitialModule_m[sensor]);
							for (int i = 0; i < 3; i++) {
								MAG_MOm[sensor][i] = MAG_MOm[sensor][i] * 0.999f + m_n[i] * 0.001f;
								MAG_Fam[sensor][i] = MAG_Fam[sensor][i] * 0.999f + Fam[i] * 0.001f;
								////////////////////////////////////
								MAG_OMOm[sensor][i] = MAG_OMOm[sensor][i] * 0.999f + m_n2[i] * 0.001f;
								MAG_OFam[sensor][i] = MAG_OFam[sensor][i] * 0.999f + Fam2[i] * 0.001f;
								////////////////////////////////////
							}
							Norm(MAG_MOm[sensor], 3);
							Norm(MAG_Fam[sensor], 3);
							Norm(MAG_OMOm[sensor], 3);
							Norm(MAG_OFam[sensor], 3);
							MAG_Zm[sensor] = MAG_MOm[sensor][2];
							MAG_InitialModule_m[sensor] = MAG_InitialModule_m[sensor] * 0.999f + mag0_ss_EKF * 0.001f;
						}
						else {
//							MAG_Change[sensor] = 1;
							////////////////////////////////////
							Copy(MAG_MOm[sensor], m_n, 3);
							Copy(MAG_Fam[sensor], Fam, 3);
							////////////////////////////////////
							Copy(MAG_OMOm[sensor], m_n2, 3);
							Copy(MAG_OFam[sensor], Fam2, 3);
							MAG_Zm[sensor] = bz2;
							for (int i = 0; i < 3; i++) {
								P_mag_ekf_temp[sensor][i] = P_MAG_EKF[sensor][i];
								P_mag_ekf_temp[sensor][i + 3] = P_MAG_EKF[sensor][i + 6];
								P_mag_ekf_temp[sensor][i + 6] = P_MAG_EKF[sensor][i + 12];
							}
							X_MAG_EKF[sensor][0] = mag_mcu[0];
							X_MAG_EKF[sensor][1] = mag_mcu[1];
							X_MAG_EKF[sensor][2] = mag_mcu[2];
							X_MAG_EKF[sensor][3] = 0;
							X_MAG_EKF[sensor][4] = 0;
							X_MAG_EKF[sensor][5] = 0;
							for (int i = 0; i < 36; i++)
							{
								P_MAG_EKF[sensor][i] = 0;		
							}
							P_MAG_EKF[sensor][0] = 1e-3f; P_MAG_EKF[sensor][7] = 1e-3f; P_MAG_EKF[sensor][14] = 1e-3f;
							P_MAG_EKF[sensor][21] = 1e-3f; P_MAG_EKF[sensor][28] = 1e-3f; P_MAG_EKF[sensor][35] = 1e-3f;
							MAG_InitialModule_m[sensor] = mag0_ss_EKF;
//							EnvironmentMagStatus[sensor] = -EnvironmentMagStatus[sensor];
						}
					}
				}
			}
			if (FixMAG == 1 && (MagModelStatus == 1 || MagModelStatus == 2)) {
				Rmag_use[sensor][0] = k_m * Rmag_static[sensor][0];
				Rmag_use[sensor][4] = k_m * Rmag_static[sensor][4];
				Rmag_use[sensor][8] = k_m * Rmag_static[sensor][8];
				H2[0] = 2 * (MAG_MO[0] * quat_EKF[sensor][0] + MAG_MO[1] * quat_EKF[sensor][3] - MAG_MO[2] * quat_EKF[sensor][2]);   H2[1] = 2 * (MAG_MO[0] * quat_EKF[sensor][1] + MAG_MO[1] * quat_EKF[sensor][2] + MAG_MO[2] * quat_EKF[sensor][3]); H2[2] = 2 * (-MAG_MO[0] * quat_EKF[sensor][2] + MAG_MO[1] * quat_EKF[sensor][1] - MAG_MO[2] * quat_EKF[sensor][0]); H2[3] = 2 * (-MAG_MO[0] * quat_EKF[sensor][3] + MAG_MO[1] * quat_EKF[sensor][0] + MAG_MO[2] * quat_EKF[sensor][1]);
				H2[4] = 2 * (-MAG_MO[0] * quat_EKF[sensor][3] + MAG_MO[1] * quat_EKF[sensor][0] + MAG_MO[2] * quat_EKF[sensor][1]); H2[5] = 2 * (MAG_MO[0] * quat_EKF[sensor][2] - MAG_MO[1] * quat_EKF[sensor][1] + MAG_MO[2] * quat_EKF[sensor][0]);  H2[6] = 2 * (MAG_MO[0] * quat_EKF[sensor][1] + MAG_MO[1] * quat_EKF[sensor][2] + MAG_MO[2] * quat_EKF[sensor][3]); H2[7] = 2 * (-MAG_MO[0] * quat_EKF[sensor][0] - MAG_MO[1] * quat_EKF[sensor][3] + MAG_MO[2] * quat_EKF[sensor][2]);
				H2[8] = 2 * (MAG_MO[0] * quat_EKF[sensor][2] - MAG_MO[1] * quat_EKF[sensor][1] + MAG_MO[2] * quat_EKF[sensor][0]);   H2[9] = 2 * (MAG_MO[0] * quat_EKF[sensor][3] - MAG_MO[1] * quat_EKF[sensor][0] - MAG_MO[2] * quat_EKF[sensor][1]); H2[10] = 2 * (MAG_MO[0] * quat_EKF[sensor][0] + MAG_MO[1] * quat_EKF[sensor][3] - MAG_MO[2] * quat_EKF[sensor][2]); H2[11] = 2 * (MAG_MO[0] * quat_EKF[sensor][1] + MAG_MO[1] * quat_EKF[sensor][2] + MAG_MO[2] * quat_EKF[sensor][3]);

				matrix_mul(H2, 3, 4, P_EKF[sensor], 4, mid1);
				matrix_trans(H2, 3, 4, mid2);
				matrix_mul(mid1, 3, 4, mid2, 3, mid3);
				matrix_add(mid3, Rmag_use[sensor], 3, 3, mid1);
//				if (MAG_Change[sensor] == 1 )
//				{
//					MAG_Change[sensor] = 0;
//					matrix_mul(Cbn, 3, 3, P_mag_ekf_temp[sensor], 4, mid3);
//					matrix_trans(Cbn, 3, 3, mid4);
//					matrix_mul(mid3, 3, 3, mid4, 3, mid5);
//					matrix_add(mid1, mid5, 3, 3, mid3);
//					Copy(mid1, mid3, 18);
//				}
				matrix_3_inv(mid1, mid3);
				matrix_mul(P_EKF[sensor], 4, 4, mid2, 3, mid1);
				matrix_mul(mid1, 4, 3, mid3, 3, K2);    //K2(4,3,k)=P2(4,4,k)*H2(3,4,k)'/(H2(3,4,k)*P2(4,4,k)*H2(3,4,k)'+R2(3,3,k));	
				matrix_mul(K2, 4, 3, H2, 4, mid1);
				matrix_sub(eye4, mid1, 4, 4, mid2);
				matrix_4_mul(mid2, P_EKF[sensor], P_temp);   //P_EKF(4,4,k)=(eye(4)-K2(4,3,k)*H2(3,4,k))*P2(4,4,k);
				Copy(P_EKF[sensor], P_temp, 16);

				matrix_mul(MAG_MO, 1, 3, Cbn, 3, mid1);
				mid2[0] = mag_EKF[0] - mid1[0];
				mid2[1] = mag_EKF[1] - mid1[1];
				mid2[2] = mag_EKF[2] - mid1[2];
				//float_temp = sqrtf(mid2[0] * mid2[0] + mid2[1] * mid2[1] + mid2[2] * mid2[2]);//�޸����ȹ�ϵ float_temp=2Rsin(Q_GYR/2),0.0157��Ӧÿ֡3�ȵ��޸���
				//Ryu = 0.12;
				//if (float_temp > Ryu) {
				//	mid2[0] = mid2[0] * Ryu / float_temp;
				//	mid2[1] = mid2[1] * Ryu / float_temp;
				//	mid2[2] = mid2[2] * Ryu / float_temp;
				//}
				// MAG�����㷨
				matrix_mul(K2, 4, 3, mid2, 1, mid1);//K2(4,3,k)*(m(3,1,k)-Hm(3,1,k));
				matrix_add(quat_EKF[sensor], mid1, 4, 1, q_temp);  //mid2=q_2(4,1,k)+K2(4,3,k)*(m(3,1,k)-Hm(3,1,k));
				w_matrix(quat_EKF[sensor], mid1, 1, 0);
				matrix_mul(q_temp, 1, 4, mid1, 4, q_temp2);
				q_temp2[1] = 0;
				q_temp2[2] = 0;
				Norm(q_temp2, 4);
				w_matrix(quat_EKF[sensor], mid1, 1, 1);
				matrix_mul(q_temp2, 1, 4, mid1, 4, q_temp);
				Copy(quat_EKF[sensor], q_temp, 4);
				if (Norm(quat_EKF[sensor], 4) == 0) { return 0; }
			}
	  }
		else{
			t_m[sensor] = t_m[sensor] - 0.03f;
		}
	}
	//���ٻع�
	if(sensorQuitTimeReturnCtrl[sensor])             //�����������ٻع飬��Ҫ���500ms�����ٴδ���
	{
		t_quit[sensor] = t_quit[sensor] + dtTime;
		sensorQuitReturnCtrl[sensor] = 0;
		QuickRecover[sensor] = 0;
		if(t_quit[sensor] > 0.5)
		{
			sensorQuitTimeReturnCtrl[sensor] = false;	
			t_quit[sensor] = 0;
		}
	}

	if (QuickRecover[sensor]|| sensorQuitReturnCtrl[sensor]) {
		if(!sensorQuitTimeReturnCtrl[sensor])
		{
			//		  EnvironmentMagStatus[sensor] = 2.1;
		
			QuickRecover[sensor] = 0;
			//FastMovementTime[sensor] = 0;
			QuitReturnCtrlNumber[sensor] = 0;
			//ACC EKF init
			Copy(X_ACC_EKF[sensor], acc_mcu, 3);
			Copy(X_MAG_EKF[sensor], mag_mcu, 3);
			X_MAG_EKF[sensor][3] = 0;
			X_MAG_EKF[sensor][4] = 0;
			X_MAG_EKF[sensor][5] = 0;
			ekf_init(sensor);
		

			//
			PRY[0] = atan2f(acc[1], acc[2]);
			PRY[1] = atan2f(-acc[0], sqrtf(acc[1] * acc[1] + acc[2] * acc[2]));
//		  if (MAG_LastTrue[sensor] == 1)
			PRY[2] = atan2f((mag[2] * sinf(PRY[0]) - mag[1] * cosf(PRY[0])),
				(mag[0] * cosf(PRY[1]) + (mag[1] * sinf(PRY[0]) + mag[2] * cosf(PRY[0])) * sinf(PRY[1])));
/*********************************************new part***************************************************/
//			else{
//				float H_x,H_y;
//				H_y = mag[2] * sinf(PRY[0]) - mag[1] * cosf(PRY[0]);
//				H_x = mag[0] * cosf(PRY[1]) + (mag[1] * sinf(PRY[0]) + mag[2] * cosf(PRY[0])) * sinf(PRY[1]);
//				PRY[2] = ACos((H_x* MAG_MOm[sensor][0] + H_y * MAG_MOm[sensor][1]) / (sqrtf(H_x * H_x + H_y * H_y) * sqrtf(MAG_MOm[sensor][0] * MAG_MOm[sensor][0] + MAG_MOm[sensor][1] * MAG_MOm[sensor][1])));
//			}
/*********************************************new part***************************************************/
			q_temp[0] = cosf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) + sinf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
			q_temp[1] = sinf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) - cosf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
			q_temp[2] = cosf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]) + sinf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]);
			q_temp[3] = cosf(0.5f * PRY[0]) * cosf(0.5f * PRY[1]) * sinf(0.5f * PRY[2]) - sinf(0.5f * PRY[0]) * sinf(0.5f * PRY[1]) * cosf(0.5f * PRY[2]);
			float cosom = quat_EKF[sensor][0] * q_temp[0] + quat_EKF[sensor][1] * q_temp[1] + quat_EKF[sensor][2] * q_temp[2] + quat_EKF[sensor][3] * q_temp[3];
			if (cosom < 0)
			{
				q_temp[0] = -q_temp[0];
				q_temp[1] = -q_temp[1];
				q_temp[2] = -q_temp[2];
				q_temp[3] = -q_temp[3];
			}
			Copy(quat_EKF[sensor], q_temp, 4);
			if (sensorQuitReturnCtrl[sensor]) { //�ϲ�ָ�һ���ɱ궨��ȡ
				matrix_Cbn(quat_EKF[sensor], Cbn);
				matrix_mul(Cbn, 3, 3, mag, 1, m_n);
				bx = sqrtf(m_n[0] * m_n[0] + m_n[1] * m_n[1]);
				by = 0;
				bz = m_n[2];

				MAG_Fa0[sensor][0] = bx;
				MAG_Fa0[sensor][1] = by;
				MAG_Fa0[sensor][2] = bz;

				float_temp = Module(MAG_Fa0[sensor], 3);
				for (int i = 0; i < 3; i++) {
					MAG_Fa0[sensor][i] /= float_temp;
					MAG_MO0[sensor][i] = MAG_Fa0[sensor][i];
					MAG_Fam[sensor][i] = MAG_Fa0[sensor][i];
					MAG_MOm[sensor][i] = m_n[i];
				}
				MAG_Z0[sensor] = bz;
				MAG_LastTrue[sensor] = 1;
				MAG_InitialModule[sensor] = mag0_ss;
			}
			if(sensorQuitReturnState[sensor] < -2.0)       //add zjh 2024/4/8   �������ٻع��־λ
			{
				sensorQuitReturnState[sensor] = 2.1;
			}
			else if(sensorQuitReturnState[sensor] > 2.0)
			{
				sensorQuitReturnState[sensor] = -2.1;
			}
			sensorQuitReturnCtrl[sensor] = 0;
			
			sensorQuitTimeReturnCtrl[sensor] = true;
		}

		
	}
	//�˲�
	float_temp = quat_EKF[sensor][0] * quat_Filter[sensor][0] + quat_EKF[sensor][1] * quat_Filter[sensor][1] + quat_EKF[sensor][2] * quat_Filter[sensor][2] + quat_EKF[sensor][3] * quat_Filter[sensor][3];
	if (float_temp < 0)
	{
		quat_EKF[sensor][0] = -quat_EKF[sensor][0];
		quat_EKF[sensor][1] = -quat_EKF[sensor][1];
		quat_EKF[sensor][2] = -quat_EKF[sensor][2];
		quat_EKF[sensor][3] = -quat_EKF[sensor][3];
		float_temp = -float_temp;
	}
	if (float_temp > 1)float_temp = 1;
	float Angle = acosf(float_temp);
	float sinAngle = sinf(Angle);
	if (sinAngle < 1e-5f) {
		Copy(quat_Filter[sensor], quat_EKF[sensor], 4);
	}
	else {
		float t = (1e-5f + (sinAngle - 1e-5f) * 0.01f) / sinAngle; //20220920
		float InvSin = 1.0f / sinAngle;
		float fCoeff0 = sinf((1 - t) * Angle);
		float fCoeff1 = sinf(t * Angle);
		quat_Filter[sensor][0] = (quat_Filter[sensor][0] * fCoeff0 + quat_EKF[sensor][0] * fCoeff1) * InvSin;
		quat_Filter[sensor][1] = (quat_Filter[sensor][1] * fCoeff0 + quat_EKF[sensor][1] * fCoeff1) * InvSin;
		quat_Filter[sensor][2] = (quat_Filter[sensor][2] * fCoeff0 + quat_EKF[sensor][2] * fCoeff1) * InvSin;
		quat_Filter[sensor][3] = (quat_Filter[sensor][3] * fCoeff0 + quat_EKF[sensor][3] * fCoeff1) * InvSin;
		Norm(quat_Filter[sensor], 4);
	}
	Copy(q_out, quat_Filter[sensor], 4);
//	if(MagModelStatus==1){
//			EnvironmentMagStatus[sensor] = 0;
//		}
//		else if(MagModelStatus==2){
//			EnvironmentMagStatus[sensor] = 2.1;	
//		}
//		else {
//			EnvironmentMagStatus[sensor] = -2.1; //Ƶ�����ڱ�ʾ�ų�ת��Ƶ��
//		}
	q_out[0] += EnvironmentMagStatus[sensor];
	q_out[1] += sensorQuitReturnState[sensor];
	return 1;
}


