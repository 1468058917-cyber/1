%% �������˲� EKF-WJ-B-3.2.2.10
%% �������˲�
classdef EKF3_2_2_10 < handle
    properties(Access =public)
        %Ԥ�����
        sensors = 1;
        P_EKF=zeros(4);Q=zeros(4);Ra=zeros(3);
        Rm=zeros(3);R1=zeros(3);R2=zeros(3);
        fa=zeros(1,3);fa_num=0;
        
        k_first=0;%У׼ʱ�����
        q_k2;
        
        magXZS; P_k1; P_k2; quat_k1; quat_k2;quat_k3;
        MAG_Fa0; MAG_MO0;MAG_Fam;MAG_MOm;fa1; t_a; t_m; pass_r=0; MAG_MO; MAG_Z0;
        MAG_OMOm;MAG_OFam;MAG_Zm;
        EnvironmentMagStatus;
        RecoverSignalEKF;
        InitNumber;MeanACC;MeanMAG;MAG_InitialModule;
        X_ACC_EKF=[0,0,0];X_MAG_EKF;MAG_LastTrue;gyrstatic;accstatic;
        accLast;FastMovementTime;QuickRecover;quat_Filter;QuitReturnCtrlNumber;
        sensorQuitReturnCtrl;
        
        jiao_acc_see=0;
        accErr_see=0;
        gyrErr_see=0;
        RecoverSignalEKF_see=0;

        P_ACC_EKF;Q_ACC_EKF;ERR_ACC_EKF;R_ACC_EKF;acc_EKF;
        P_MAG_EKF;Q_MAG_EKF;R_MAG_EKF;mag_EKF;

        quat_EKF;Racc_use;Racc_static;MAG_InitialModule_m;
        Rmag_use;Rmag_static;
        gyr_vec_flag=0;
        refer_dtime = 0;
        refer_dtimeTh = 1;
        
        quat_GYR=[1,0,0,0];
    end
    
    methods(Access =public)
        function self=EKF3_2_2_10() %��ʼ��ʵ������
            self.ekf_init();
            self.k_first = 0;
            self.fa = zeros(1,3);
            self.fa_num = 0;
            self.InitNumber = 1;
            self.MAG_Fa0 = zeros(1,3);
            self.MeanACC = zeros(1,3);
            self.MeanMAG = zeros(1,3);
            self.MAG_InitialModule = 0;
        end
        %%
        function ekf_init(self)
            self.P_EKF=eye(4)*1e-1;%quaternion variance when in calculate
            self.Q=eye(4)*1e-2;%gyroscope variance��û�и��£�ֱ����
            self.Racc_static=eye(3)*1e+2;
            self.Rmag_static=eye(3)*8e+2;
            self.R1=zeros(3); %accelerometer variance
            self.R2=zeros(3); %magetomeeter variance
            self.ACCEKF_init();
            self.MAGEKF_init();

            self.sensorQuitReturnCtrl = 0;
        end
        function ACCEKF_init(self)
            self.ERR_ACC_EKF=0;
            self.P_ACC_EKF = eye(3)*1e-3;
            self.Q_ACC_EKF = eye(3)*3e-1;
            self.R_ACC_EKF = eye(3)*1e+3;
        end
        function MAGEKF_init(self)
            self.P_MAG_EKF = eye(6)*1e-3;
            self.Q_MAG_EKF = eye(6)*1e-2;
            self.R_MAG_EKF = eye(3)*1e+2;
        end
        %**********************************************************************
        % 3.2.2.10
        function q_out=KalmanFilter(self, acc_mcu, gyr_mcu, mag_mcu, dtTime)
            MagModelStatus=1;
            g=9.8;
            eye4=eye(4);
            acc=acc_mcu;
            gyr=gyr_mcu;
            mag=mag_mcu;
            if(all(acc==0)||all(mag==0))
                disp('acc || mag ��Ϊ0');
                q_out=zeros(1,4);
                return;
            end
            acc_update = 0;
            mag0_s=sum(mag.*mag); %element times,quadratic
            mag0_ss=sqrt(mag0_s); 
            acc0_s=sum(acc.*acc); %element times,quadratic
            acc0_ss=sqrt(acc0_s);
            gyr0_s=sum(gyr.*gyr); %element times,quadratic
            gyrErr = sqrt(gyr0_s);
            accErr = abs(acc0_ss - g);
            if acc0_ss ~=0
                acc=acc/acc0_ss;
            end
            if mag0_s>0                      %?
                mag=mag / mag0_ss;     %?
            end                              %?
            if (self.k_first <= 0.1)  %0.1ʱ���ڲ���У׼
                if (accErr < 0.5 && gyrErr < 0.5)
                    self.k_first = self.k_first+dtTime;
                else
                    self.k_first = 0;
                    self.InitNumber = 1;
                    self.MAG_Fa0 = zeros(1,3);
                    self.MeanACC = zeros(1,3);
                    self.MeanMAG = zeros(1,3);
                    self.MAG_InitialModule = 0;
                end
                self.ekf_init();
                
                for ii=1:3
                    self.MeanACC(ii)=((self.InitNumber-1)*self.MeanACC(ii)+acc(ii)) /self.InitNumber;
                    self.MeanMAG(ii)=((self.InitNumber-1)*self.MeanMAG(ii)+mag(ii)) /self.InitNumber;
                    self.MAG_InitialModule = ((self.InitNumber - 1)*self.MAG_InitialModule + mag0_ss) / self.InitNumber;
                end

                self.X_ACC_EKF = acc_mcu;
                self.X_MAG_EKF = [mag,zeros(1,3)];

                %ֻ�ü��ٶȼƺʹ����Ƽ������ת�ǶȺͶ�Ӧ����Ԫ�����������У�(����ֻ��������ƽ��)
                PRY(1) = atan2(self.MeanACC(2), self.MeanACC(3));
                PRY(2) = atan2(-self.MeanACC(1), sqrt(self.MeanACC(2) * self.MeanACC(2) + self.MeanACC(3) * self.MeanACC(3)));
                PRY(3) = atan2((self.MeanMAG(3) * sin(PRY(1)) - self.MeanMAG(2) * cos(PRY(1))),(self.MeanMAG(1) * cos(PRY(2)) + (self.MeanMAG(2) * sin(PRY(1)) + self.MeanMAG(3) * cos(PRY(1))) * sin(PRY(2))));
                self.quat_EKF(1) = cos(0.5 * PRY(1)) * cos(0.5 * PRY(2)) * cos(0.5 * PRY(3)) + sin(0.5 * PRY(1)) * sin(0.5 * PRY(2)) * sin(0.5 * PRY(3));
                self.quat_EKF(2) = sin(0.5 * PRY(1)) * cos(0.5 * PRY(2)) * cos(0.5 * PRY(3)) - cos(0.5 * PRY(1)) * sin(0.5 * PRY(2)) * sin(0.5 * PRY(3));
                self.quat_EKF(3) = cos(0.5 * PRY(1)) * sin(0.5 * PRY(2)) * cos(0.5 * PRY(3)) + sin(0.5 * PRY(1)) * cos(0.5 * PRY(2)) * sin(0.5 * PRY(3));
                self.quat_EKF(4) = cos(0.5 * PRY(1)) * cos(0.5 * PRY(2)) * sin(0.5 * PRY(3)) - sin(0.5 * PRY(1)) * sin(0.5 * PRY(2)) * cos(0.5 * PRY(3));

                m_n=self.MeanMAG*T_SY(self.quat_EKF)'; %��֤��ʽ��ȷ   (b->e��������ԭ�����ǻ���b�ģ���ע������'����ת�õ�
                bx=sqrt(m_n(1)^2+m_n(2)^2);%��e����ϵ��,��ָ���ϼ�������
                by=0;                      %��e����ϵ��
                bz=m_n(3);
                self.MAG_Fa0=[bx,by,bz];
                float_temp = module(self.MAG_Fa0);
                self.MAG_Fa0 = self.MAG_Fa0/float_temp;
                self.MAG_MO0=self.MAG_Fa0;        %e������������ݣ���������g������������
                self.MAG_Fam = self.MAG_Fa0;
                self.MAG_MOm = m_n;
                self.MAG_Z0 = bz ;
                self.MAG_LastTrue=1;
                self.quat_Filter = self.quat_EKF;
                self.quat_GYR = self.quat_EKF;
                q_out=self.quat_EKF;
                self.t_a=0;
                self.t_m=0.015;
                self.InitNumber = self.InitNumber+1;
                self.EnvironmentMagStatus = 2.1;
                self.accLast = acc_mcu;
                self.QuitReturnCtrlNumber = 0;
                self.QuickRecover = 0;
                self.gyr_vec_flag=0;
                
                self.acc_EKF = acc_mcu;
                return;
            end



            %Ԥ�ⲿ��
            if (gyrErr > 0.05&&dtTime<0.1)
                %ACC
                A_ACC = [1,-gyr(3)*dtTime,gyr(2)*dtTime;...
                gyr(3)*dtTime,1,-gyr(1)*dtTime;...
                -gyr(2)*dtTime,gyr(1)*dtTime,1];
                self.X_ACC_EKF = self.X_ACC_EKF*A_ACC;
                self.P_ACC_EKF = A_ACC'*self.P_ACC_EKF*A_ACC+self.Q_ACC_EKF;
                %MAG
                self.gyr_vec_flag=0;
                A_MAG_EKF=eye(6);
                A_MAG_EKF(1:3,1:3)=eye(3)+[0,-gyr(3),gyr(2);gyr(3),0,-gyr(1);-gyr(2),gyr(1),0]*dtTime;
                self.X_MAG_EKF(1:3) = self.X_MAG_EKF(1:3)*A_ACC;
                self.P_MAG_EKF = A_MAG_EKF'*self.P_MAG_EKF*A_MAG_EKF+self.Q_MAG_EKF;
                %ekf��Ԥ�ⲿ�֣���ת�ǶȺʹ���0.5��Ԥ�⣬�������ԭֵ

                A=w_matrix([1,gyr*dtTime*0.5],1);%A is a linear matrix,the coefficent of the q dont include multi times item
                self.quat_EKF=self.quat_EKF*A';
                self.quat_EKF=self.Norm(self.quat_EKF);

                self.quat_Filter=self.quat_Filter*A';
                self.quat_Filter=self.Norm(self.quat_Filter);
                
                self.quat_GYR=self.quat_GYR*A';
                self.quat_GYR=self.Norm(self.quat_GYR);

                self.P_EKF=A*self.P_EKF*A'+self.Q;
                temp = 100;
                %limit ��ֵ
                self.P_EKF(self.P_EKF>temp)=temp;
                self.P_EKF(self.P_EKF<-temp)=-temp;
            end

       
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            self.t_a=self.t_a+dtTime;%t_a��ʾ���ٶȼƵ��ۼ�ʱ��
            if ((self.t_a > 0.03)&&accErr<0.5&&1)%�ۼ�ʱ�䳬��0.03�Ž���
                self.t_a=self.t_a-0.03;
                acc_update = 1;%��ʾ����
                self.accLast = acc;
                if (accErr<2)
                    float_temp = gyrErr*accErr+1e-4;
                    maxerr = max(float_temp,self.ERR_ACC_EKF);
                    mid = self.R_ACC_EKF*maxerr;
                    K_ACC = self.P_ACC_EKF/(self.P_ACC_EKF+mid);
                    self.ERR_ACC_EKF = float_temp;
                    mid = acc_mcu-self.X_ACC_EKF;
                    self.X_ACC_EKF = self.X_ACC_EKF+mid*K_ACC';
                    self.P_ACC_EKF = (eye(3)-K_ACC)*self.P_ACC_EKF;
                end
                self.acc_EKF = self.X_ACC_EKF;
                self.acc_EKF= self.Norm(self.acc_EKF);
            end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            %�����Ǽ��ٶȼƵĸ���
            %ȡ���������ٶ���b����ϵ�µı�ʾ
            acc_T(1) = 2 * (self.quat_EKF(2) * self.quat_EKF(4) - self.quat_EKF(1) * self.quat_EKF(3));
            acc_T(2) = 2 * (self.quat_EKF(3) * self.quat_EKF(4) + self.quat_EKF(1) * self.quat_EKF(2));
            acc_T(3) = self.quat_EKF(1) * self.quat_EKF(1) - self.quat_EKF(2) * self.quat_EKF(2) - self.quat_EKF(3) * self.quat_EKF(3) + self.quat_EKF(4) * self.quat_EKF(4);
            if (acc0_ss > 0)%���ٶȺ�g�����ͻ�ȡ������b�µı�ʾ�ͼ��ٶȼƵ����֮��ĽǶȣ����ڻ�ȡ��
                jiao_acc = self.ACos(self.acc_EKF(1) * acc_T(1) + self.acc_EKF(2) * acc_T(2) + self.acc_EKF(3) * acc_T(3));%��ȡ
            else
                jiao_acc = 100;
            end
            
            if (acc_update == 1|| self.sensorQuitReturnCtrl==1)
                if (accErr > 10 && gyrErr > 10)
                    self.QuitReturnCtrlNumber = self.QuitReturnCtrlNumber+0.1;
                elseif (accErr < 0.8 && gyrErr < 0.5)
                    if (jiao_acc > 0.4)
                        self.QuitReturnCtrlNumber = self.QuitReturnCtrlNumber+ 0.1;
                    else
                        self.QuitReturnCtrlNumber = self.QuitReturnCtrlNumber- 0.02;
                    end
                elseif (accErr < 2 && gyrErr < 1)
                    self.QuitReturnCtrlNumber = self.QuitReturnCtrlNumber- 0.02;
                end
                if (self.QuitReturnCtrlNumber < 0)
                    self.QuitReturnCtrlNumber = 0;
                end
                if((self.QuitReturnCtrlNumber > 10 || self.sensorQuitReturnCtrl==1)&& accErr < 0.8 && gyrErr < 0.5)
                    self.QuickRecover = 1;
                end
            end
                %ͬʱ��ʾ�����������
            if(acc_update==1)
                 if (((accErr < 1)&&(gyrErr<1)&&(jiao_acc<0.5))||((accErr<0.5)&&(gyrErr<0.2)))%
                        if((accErr < 0.2)&&(gyrErr<0.2))
                            k_a = 1 + 10 * abs(acc0_s - g * g);
                        elseif((accErr < 0.5)&&(gyrErr<0.5))
                            k_a = 1 + 50 * abs(acc0_s - g * g);
                        else
                            k_a = 1 + 100 * abs(acc0_s - g * g)*(1+jiao_acc*20);
                        end
                        self.Racc_use = k_a * self.Racc_static;       %����ķ���Ϊʲô��ôд(���Խ��,����Խ��,������)
                                                       % ,��Ӧ����H�����������jocabian��Ȼ��JRJ'�����ǿ��ܼ�����̫��
                        %���������n->b����Ԫ����ת����b->n��ת�ã�������������ٲ𿪣��������ܵĹ���Z = H_MAG_EKF��q��
                        H1 = 2*[- self.quat_EKF(3),  self.quat_EKF(4), - self.quat_EKF(1), self.quat_EKF(2);...
                              self.quat_EKF(2),   self.quat_EKF(1),  self.quat_EKF(4), self.quat_EKF(3);...
                              self.quat_EKF(1), -  self.quat_EKF(2), - self.quat_EKF(3),  self.quat_EKF(4)];
                        K1=self.P_EKF*H1'/(H1*self.P_EKF*H1'+self.Racc_use);
                        %Z-H_MAG_EKF(q) Cnb��ͺ���q
                        mid1(1) = self.acc_EKF(1) -  acc_T(1);
                        mid1(2) = self.acc_EKF(2) -  acc_T(2);
                        mid1(3) = self.acc_EKF(3) -  acc_T(3);
                        %����ģ������һЩ�������仯�Ĳ�������
                        dist_ACC1 = mid1(1) * mid1(1) + mid1(2) * mid1(2) + mid1(3) * mid1(3);
                        temp = sqrt(dist_ACC1);%�޸����ȹ�ϵ temp=2Rsin(Q/2),1��Ӧÿ֡5.8�ȵ��޸���
                        Ryu = 0.08;
                        if (temp > Ryu)
                            mid1(1) = mid1(1) * Ryu / temp;
                            mid1(2) = mid1(2) * Ryu / temp;
                            mid1(3) = mid1(3) * Ryu / temp;
                        end
                        % ����������90��ʱ�����ٶ������ᱻ�������ƻ�������㷨����쳣����
                        % ���ٶ���̬�ں�����������ģ�飬���������������̬�ں��쳣
                        mid2=mid1*K1';
                    qtemp=self.quat_EKF+mid2;
                    qtemp=self.Norm(qtemp);
                    acc_T(1) = 2 * (qtemp(2) * qtemp(4) - qtemp(1) * qtemp(3));
                    acc_T(2) = 2 * (qtemp(3) * qtemp(4) + qtemp(1) * qtemp(2));
                    acc_T(3) = 1 - 2 * qtemp(2) * qtemp(2) - 2 * qtemp(3) * qtemp(3);
                    mid1(1) = self.acc_EKF(1) -  acc_T(1);
                    mid1(2) = self.acc_EKF(2) -  acc_T(2);
                    mid1(3) = self.acc_EKF(3) -  acc_T(3);
                    dist_ACC2 = mid1(1) * mid1(1) + mid1(2) * mid1(2) + mid1(3) * mid1(3);
                    
                    qtemp2=self.quat_EKF-mid2;
                    qtemp2=self.Norm(qtemp2);
                    acc_T(1) = 2 * (qtemp2(2) * qtemp2(4) - qtemp2(1) * qtemp2(3));
                    acc_T(2) = 2 * (qtemp2(3) * qtemp2(4) + qtemp2(1) * qtemp2(2));
                    acc_T(3) = 1 - 2 * qtemp2(2) * qtemp2(2) - 2 * qtemp2(3) * qtemp2(3);
                    mid1(1) = self.acc_EKF(1) -  acc_T(1);
                    mid1(2) = self.acc_EKF(2) -  acc_T(2);
                    mid1(3) = self.acc_EKF(3) -  acc_T(3);
                    dist_ACC3 = mid1(1) * mid1(1) + mid1(2) * mid1(2) + mid1(3) * mid1(3);
                    if dist_ACC2<dist_ACC3
                        if dist_ACC1>dist_ACC2
                        self.quat_EKF=qtemp;
                        self.P_EKF=(eye4-K1*H1)*self.P_EKF;
                        end
                    else
                        if dist_ACC1>dist_ACC3
                        self.quat_EKF=qtemp2;
                        self.P_EKF=(eye4+K1*H1)*self.P_EKF;
                        end
                    end
                 end
            end
            


            %�����Ǵ����Ƶ�
            self.t_m = self.t_m + dtTime;%t_a��ʾ�����Ƶ��ۼ�ʱ��
            if (self.t_m > 0.03&&1)%�ۼ�ʱ�䳬��0.03�Ž���
                if gyrErr >0.05
                    m_n2=mag*T_SY(self.quat_EKF)';
                    bx2 = sqrt(m_n2(1)^2+m_n2(2)^2);
                    bz2 = m_n2(3);
                    Fam2 = [bx2,0,bz2];
                    jiao_mag_2 = abs(atan2(m_n2(2),m_n2(1)));
                    jiao0_2 = self.ACos(Fam2(1) * self.MAG_Fa0(1) + Fam2(3) * self.MAG_Fa0(3));
                    k_m = 1;
                    self.t_m = self.t_m - 0.03;
                    self.gyr_vec_flag = self.gyr_vec_flag+1;
                    if (self.gyr_vec_flag<=2)
                        self.Rmag_use = k_m * self.R_MAG_EKF;
                        H_MAG_EKF = [eye(3);eye(3)];
                        K_MAG_EKF = self.P_MAG_EKF*H_MAG_EKF/(H_MAG_EKF'*self.P_MAG_EKF*H_MAG_EKF+self.Rmag_use);
                        mid1 = self.X_MAG_EKF*H_MAG_EKF;
                        mid = mag_mcu-mid1;
                        self.X_MAG_EKF = self.X_MAG_EKF+mid*K_MAG_EKF';
                        self.P_MAG_EKF = (eye(6)-K_MAG_EKF*H_MAG_EKF')*self.P_MAG_EKF;
                    end
    
                    self.mag_EKF = self.X_MAG_EKF(1:3);
%                      self.mag_EKF = mag;
    %                 mag0_ss_EKF = norm(self.mag_EKF,2)^2;
                    mag0_s_EKF=sum(self.mag_EKF.*self.mag_EKF);
                    mag0_ss_EKF = sqrt(mag0_s_EKF);
                    self.mag_EKF=self.Norm(self.mag_EKF);
    
                    m_n=self.mag_EKF*T_SY(self.quat_EKF)'; %��֤��ʽ��ȷ   (b->e��������ԭ�����ǻ���b�ģ���ע������'����ת�õ�
    %                 ms = mag0_ss;
                    bx=sqrt(m_n(1)^2+m_n(2)^2);%��e����ϵ��,��ָ���ϼ�������
                    by=0;                      %��e����ϵ��
                    bz=m_n(3);
                    Fam = [bx,by,bz];
                    FixMAG = 0;
                    if (mag0_ss < 0.5&&mag0_ss>0.15)
                        self.EnvironmentMagStatus = 0;
                    else
                        self.EnvironmentMagStatus = -2.1;
                    end
                    if (((jiao0_2 <0.18) &&(jiao_mag_2<0.15)&&(abs(bz2-self.MAG_Z0)<0.08)&&(abs(mag0_ss-self.MAG_InitialModule)<0.08))|| ((jiao0_2 <0.1) && (abs(bz2 - self.MAG_Z0) < 0.05) &&(abs(mag0_ss-self.MAG_InitialModule)<0.05))&& (mag0_ss < 0.5) && (mag0_ss > 0.15)&&MagModelStatus==1)
                        if self.MAG_LastTrue==0
                            self.P_MAG_EKF= eye(6)*1e-3;
                        end
                        self.MAG_LastTrue = 1;
                        FixMAG = 1;
                        self.MAG_MO = self.MAG_MO0;
                        k_m =  1+50*abs(mag0_s - self.MAG_InitialModule * self.MAG_InitialModule);
                        
                        self.X_MAG_EKF(4:6) = zeros(1,3);
                    else
                        if ((MagModelStatus == 1) || (MagModelStatus == 2))
                            if(self.MAG_LastTrue == 1)
                                self.MAG_LastTrue = 0;
                                self.MAG_MOm = m_n;
                                self.MAG_Fam = Fam;
                                self.MAG_OMOm = m_n2;
                                self.MAG_OFam = Fam2;
                                self.MAG_Zm = bz2;
                                self.X_MAG_EKF(1:3)= mag_mcu;
                                self.X_MAG_EKF(4:6) = zeros(1,3);
                                self.P_MAG_EKF = eye(6)*1e-3;
                                self.MAG_InitialModule_m = mag0_ss_EKF;
                            else
                                jiaom = self.ACos(Fam(1) * self.MAG_Fam(1) + Fam(3) * self.MAG_Fam(3));
                                jiaom_mag = self.ACos((m_n(1) * self.MAG_MOm(1) +m_n(2) * self.MAG_MOm(2))/ (Fam(1)*sqrt(self.MAG_MOm(1)*self.MAG_MOm(1)+self.MAG_MOm(2)*self.MAG_MOm(2))));
                                jiaomThresold = 0.15;
                                jiaommagThresold = 0.08;
                                if((jiaom < jiaomThresold) &&(jiaom_mag<jiaommagThresold)&&(abs(bz2-self.MAG_Zm)<0.1)&&(abs(mag0_ss_EKF-self.MAG_InitialModule_m)<0.1))
                                    FixMAG = 1;
                                    self.MAG_MO = self.MAG_MOm;
                                    k_m =  1+50*abs(mag0_s_EKF - self.MAG_InitialModule * self.MAG_InitialModule);
                                    self.MAG_MOm = 0.999*self.MAG_MOm+m_n*0.001;
                                    self.MAG_Fam = 0.999*self.MAG_Fam+Fam*0.001;
                                    self.MAG_MOm = self.Norm(self.MAG_MOm);
                                    self.MAG_Fam = self.Norm(self.MAG_Fam);
                                    self.MAG_OMOm = 0.999*self.MAG_OMOm+m_n2*0.001;
                                    self.MAG_OFam = 0.999*self.MAG_OFam+Fam2*0.001;
                                    self.MAG_OMOm = self.Norm(self.MAG_OMOm);
                                    self.MAG_OFam = self.Norm(self.MAG_OFam);
                                    self.MAG_Zm = self.MAG_MOm(3);
                                    self.MAG_InitialModule_m = 0.999*self.MAG_InitialModule_m+mag0_ss_EKF*0.001;
                                else
                                    self.MAG_MOm = m_n;
                                    self.MAG_Fam = Fam;
                                    self.MAG_OMOm = m_n2;
                                    self.MAG_OFam = Fam2;
                                    self.MAG_Zm = bz2;
                                    self.X_MAG_EKF(1:3)= mag_mcu;
                                    self.X_MAG_EKF(4:6) = zeros(1,3);
                                    self.P_MAG_EKF = eye(6)*1e-3;
                                    self.MAG_InitialModule_m = mag0_ss_EKF;
                                end
                            end
                        end  
                    end
                
    
                    if ((FixMAG == 1) &&(MagModelStatus == 1 || MagModelStatus == 2)&&1)
                        self.Rmag_use = k_m * self.Rmag_static;
                        %ͬ�����������n->b����Ԫ����ת����b->n��ת�ã�����M_b=MAG_MO*T_SY(q_2)'��H2�����ľ���MO����ת����İ���ϣ��������ܵĹ���Z = H_MAG_EKF��q��
                        H2 = 2*[self.MAG_MO(1) * self.quat_EKF(1) + self.MAG_MO(2) * self.quat_EKF(4) - self.MAG_MO(3) * self.quat_EKF(3),self.MAG_MO(1) * self.quat_EKF(2) + self.MAG_MO(2) * self.quat_EKF(3) + self.MAG_MO(3) * self.quat_EKF(4),-self.MAG_MO(1) * self.quat_EKF(3) + self.MAG_MO(2) * self.quat_EKF(2) - self.MAG_MO(3) * self.quat_EKF(1), -self.MAG_MO(1) * self.quat_EKF(4) + self.MAG_MO(2) * self.quat_EKF(1) + self.MAG_MO(3) * self.quat_EKF(2);...
                            -self.MAG_MO(1) * self.quat_EKF(4) + self.MAG_MO(2) * self.quat_EKF(1) + self.MAG_MO(3) * self.quat_EKF(2),self.MAG_MO(1) * self.quat_EKF(3) - self.MAG_MO(2) * self.quat_EKF(2) + self.MAG_MO(3) * self.quat_EKF(1), self.MAG_MO(1) * self.quat_EKF(2) + self.MAG_MO(2) * self.quat_EKF(3) + self.MAG_MO(3) * self.quat_EKF(4),-self.MAG_MO(1) * self.quat_EKF(1) - self.MAG_MO(2) * self.quat_EKF(4) + self.MAG_MO(3) * self.quat_EKF(3);...
                            self.MAG_MO(1) * self.quat_EKF(3) - self.MAG_MO(2) * self.quat_EKF(2) + self.MAG_MO(3) * self.quat_EKF(1),self.MAG_MO(1) * self.quat_EKF(4) - self.MAG_MO(2) * self.quat_EKF(1) - self.MAG_MO(3) * self.quat_EKF(2),self.MAG_MO(1) * self.quat_EKF(1) + self.MAG_MO(2) * self.quat_EKF(4) - self.MAG_MO(3) * self.quat_EKF(3), self.MAG_MO(1) * self.quat_EKF(2) + self.MAG_MO(2) * self.quat_EKF(3) + self.MAG_MO(3) * self.quat_EKF(4)];
                        K2=self.P_EKF*H2'/(H2*self.P_EKF*H2'+self.Rmag_use);
                        self.P_EKF=(eye4-K2*H2)*self.P_EKF;
                        mid1=self.MAG_MO*T_SY(self.quat_EKF);%ֻ��ų�������������ת����b�µı�ʾ���ҳˣ�n->b
                        mid2=self.mag_EKF-mid1;
                    % MAGȥ����㷨    
                    q_temp=self.quat_EKF+mid2*K2';
                    q_temp=self.Norm(q_temp);
                    mid = w_matrix(self.quat_EKF,1);
                    q_temp2 = q_temp*mid;
                    q_temp2(2) = 0;q_temp2(3)=0;
                    q_temp2 = self.Norm(q_temp2);
                    self.quat_EKF=q_temp2*mid';
                    self.quat_EKF = self.Norm(self.quat_EKF);
                    end
                else
                    self.t_m = self.t_m - 0.03;
                end
            end
            float_temp = sum(self.quat_EKF.*self.quat_Filter);
            if (float_temp < 0)
                self.quat_EKF = -self.quat_EKF;
                float_temp = -float_temp;
            end
            if (float_temp > 1)
                float_temp = 1;
            end
            Angle = self.ACos(float_temp);
            sinAngle = sin(Angle);
            if (sinAngle < 1e-5)
                self.quat_Filter = self.quat_EKF;
            else
                t = (1e-5 + (sinAngle - 1e-5) * 0.01) / sinAngle;
                InvSin = 1.0 / sinAngle;
                fCoeff0 = sin((1 - t) * Angle);
                fCoeff1 = sin(t * Angle);
                self.quat_Filter = (self.quat_Filter * fCoeff0 + self.quat_EKF * fCoeff1) * InvSin;
                self.quat_Filter = self.Norm(self.quat_Filter);
            end
            self.quat_Filter = self.quat_EKF;
            q_out = self.quat_Filter;
        end
    end
%%

%%
    %     methods(Access =private)
    methods(Access =public)
        function out=Norm(self, vec)
            out=vec/module(vec);
        end
        function out=ASin(self, value)
            if (value >= 1)
                out= pi/2;
            elseif (value <= -1)
                out= -pi/2;
            else
                out= asin(value);
            end
        end
        function out=ACos(self, value)
            if (value >= 1)
                out= 0;
            elseif (value <= -1)
                out= pi;
            else
                out= acos(value);
            end
        end
        function out=antisymmetry(self,vect)
            out = [0,-vect(3),vect(2);...
                vect(3),0,-vect(1);...
                -vect(2),vect(1),0];
        end
    end
end
